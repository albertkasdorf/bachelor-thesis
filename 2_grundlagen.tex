\begin{comment}
------------------------------------------------------------------------------------------
\end{comment}
\chapter{Grundlagen}


\begin{comment}
------------------------------------------------------------------------------------------
- https://de.wikipedia.org/wiki/Fading_(Elektrotechnik)
\end{comment}
\section{Verfahren für die Entfernungsbestimmung}

Bei der \textit{Triangulation} werden die Winkel zwischen mehreren Referenzpunkten bestimmt und dann die dazu gehörige Entfernung mittels trigonometrischer Funktionen berechnet. Dieses Verfahren ist auch unter den Namen \Gls{aoa} bzw. \Gls{doa} bekannt. Um eine genau Ortsbestimmung durchzuführen müssen die Winkel sehr genau bestimmt werden. Um das zu bewerkstelligen werden im Empfänger mehrere Antennen zu einem Feld (engl. Antenna Array) zusammengefasst. Jedoch ist diese Konstruktion sehr teuer und empfindlich für Mehrwegeempfang (engl. Multipath) bzw. Signalabschattungen. \cite{gezici2005localization, liu2007survey, decawave2014rtls}

Im Gegensatz dazu werden bei der \textit{Trilateration} die Entfernungen zwischen mehreren Referenzpunkten betrachtet. Es werden dabei die Verfahren \Gls{toa} und \Gls{tdoa} unterschieden.
Bei dem \Gls{toa}--Verfahren wird zuerst die Zeitdifferenz zwischen dem Senden und Empfangen eines Funksignals berechnet. Mittels der Signallaufzeit (engl. \acrfull{tof}) und der Ausbreitungsgeschwindigkeit des Funksignals kann die Entfernung berechnet werden. Die Ortsbestimmung erfolgt dann über die Schnittpunkte von drei Kreisen (2D) bzw. vier Kugeln (3D) miteinander. Um dieses Verfahren anwenden zu können, ist es erforderlich das das Funksignal mit einem Zeitstempel des Startzeitpunktes versehen ist. Daraus folgt aber auch, das die Zeit zwischen Sender und Empfänger sehr genau synchronisiert werden müssen um den Fehler möglich klein zu halten.
Bei dem \Gls{tdoa}--Verfahren werden die Zeitdifferenz zwischen dem Empfang des Funksignals an mehreren Empfängern ausgewertet. Dies hat den großen Vorteil das nur noch die Zeit zwischen den Empfängern synchronisiert werden muss. \cite{zekavat2011handbook, decawave2014rtls}

Neben der \textit{Triangulation} und \textit{Trilateration} besteht auch die Möglichkeit auf Grund der empfangenen Signalstärke (engl. \acrfull{ss_radio}, \acrfull{rss} oder auch \acrfull{rssi}) Rückschlüsse über die Entfernung zu ziehen. Dazu muss die ursprüngliche Signalstärke und die Ausbreitungscharakteristik der elektromagnetischen Welle in der spezifischen Umgebung bekannt sein. \cite{gezici2005localization, decawave2014rtls}

In den nächsten zwei Abschnitten werden die \textit{DecaWave} Entfernungsmessverfahren vorgestellt. Diese haben den Vorteil, dass keine Synchronisierung der Zeit zwischen Sender und Empfänger notwendig ist. Weiterhin besitzen die \textit{DecaWave} \Gls{uwbt} zwei Eigenschaften die die Entfernungsmessung ideal ergänzt. Zum einen wird jede erhaltene Nachricht mit einem lokalen Zeitstempel versehen, der über eine minimale Auflösung von ungefähr \SI{15.65}{\pico\second} verfügt. Hiermit wäre eine theoretische Ortsauflösung von ungefähr \SI{5}{\milli\metre} möglich. Des Weiteren ist es möglich, den Sendezeitpunkt einer Nachricht in die Zukunft zu legen. Damit lässt sich die Zeitspanne zwischen dem Empfang und der Antwort auf eine Nachricht im Voraus berechnen. Die Zeitspanne kann dann der Antwortnachricht als Nutzlast mitgegeben werden, um beim Empfänger die Umlaufzeit zu berechnen.


\begin{comment}
------------------------------------------------------------------------------------------
- Wie lange dauert es bis eine Nachricht ausgetauscht worden ist?
	- Beispiel mit einer konkreten Entfernung?
	
- Wie schnell drifted ein Quarz in einem µc?
	- What is the ppm in the crystal oscillator?
	- https://electronics.stackexchange.com/questions/15851/what-is-the-ppm-in-the-crystal-oscillator
	- In the 1930s, such precise time measurements simply weren't possible; a clock of the required accuracy was difficult enough to build in fixed form, let alone portable. A crystal oscillator, for instance, drifts about 1 to 2 seconds in a month, or 1.4x10−3 seconds an hour.[1] This may sound small, but as light travels 3x108 m/s, this represents a drift of 400 m per hour. Only a few hours of flight time would render such a system unusable, a situation that remained in force until the introduction of commercial atomic clocks in the 1960s.
	- Clock accuracy in ppm
	- http://www.best-microcontroller-projects.com/ppm.html
	

\end{comment}
\subsection{\acrlong{sstwr}}

Das einfachste Verfahren, um aus der Umlaufzeit die Entfernung abzuschätzen, ist das \Gls{sstwr}--Verfahren. Dabei sendet der \Gls{tag} eine Nachricht an den \Gls{anchor} und wartet ab, bis eine entsprechende Antwortnachricht eintrifft. Beide Module erhalten einen Zeitstempel für den Versand und Empfang von Nachrichten. Aus diesen kann dann die Antwort-- ($T_{reply}$) und Umlaufzeit ($T_{round}$) berechnet werden, siehe \figurename~\ref{fig:single_sided_two_way_ranging}. \cite{decawave2015twr, decawave2016dw1kusermanual}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\linewidth]{single_sided_two_way_ranging}
	\caption{Ablauf des \acrlong{sstwr}.}
	\source{\citetitle{decawave2016dw1kusermanual} \cite{decawave2016dw1kusermanual}}
	\label{fig:single_sided_two_way_ranging}
\end{figure}

Die ungefähre \Gls{tof}--Zeitspanne ergibt sich aus der folgenden Gleichung:

\[T_{prop}=\frac{1}{2}\left(T_{round}-T_{reply}\right)\]

Damit der \Gls{tag} die \Gls{tof}--Zeitspanne berechnen kann, benötigt er die $T_{reply}$--Zeitspanne. Zu diesem Problem gibt es mehrere Lösungen. Die einfachste Lösung ist eine feste Antwortzeit die jedem Modul bekannt ist. Alternativ kann der \Gls{anchor} in der Antwortnachricht seine individuelle Antwortzeit übermitteln. Oder der \Gls{tag} übermittelt dem \Gls{anchor} mit der initialen Nachricht wie lange der \Gls{anchor} warten muss bis er die Antwortnachricht verschickt. Hierbei muss die Zeitspanne groß genug gewählt sein, um den \Gls{anchor} die Möglichkeit zur Antwort zu lassen. Je nach Anforderung wird eine der vorherigen Methoden verwendet.

Der Nachteil bei diesem Verfahren besteht in dem Fehler der von der Antwortzeit abhängt. Bei Module verwenden zur Berechnung von $T_{round}$ und $T_{reply}$ ihre lokalen Zeitgeber. Beide Zeitgeber haben einen Offsetfehler $e_{A}$ und $e_{B}$ der von der Nennfrequenz abweicht. Die daraus abgeleitete \Gls{tof}--Zeitschätzung hat damit einen Fehler der mit der Antwortzeit wächst:

\[error\approx\frac{1}{2}\left(e_B-e_A\right)\times T_{reply}\]


\begin{comment}
------------------------------------------------------------------------------------------
- \cite{decawave2016dw1kusermanual}
	- Where the clock in device A runs at ka times the desired frequency and the clock in device B runs at kb times the desired frequency and both ka & kb are close to 1.
	- To give some idea of the size of this error, if devices A and B have clocks where each are 20 ppm away (the worst case specification) from the nominal clock in directions which make their combined error additive and equal to 40 ppm, then ka and kb might both be 0.99998 or 1.00002.
	- Even with a relatively large UWB operating range of say 100 m, the TOF is just 333 ns, so the error is 20 × 10-6 × 333 × 10-9 seconds, which is 6.7 × 10-12 seconds or 6.7 picoseconds which is approximately 2.2 mm.
\end{comment}
\subsection{\acrlong{dstwr}}\label{subsec:double_sided_two_way_ranging}

Das \Gls{dstwr}--Verfahren stellt eine Verbesserung gegenüber dem \Gls{sstwr}--Verfahren dar. Hierbei werden nun drei Nachrichten verwendet um jeweils die Umlaufzeiten zwischen \Gls{tag} und \Gls{anchor}, und \Gls{anchor} und \Gls{tag} zu berechnen, siehe \figurename~\ref{fig:double_sided_two_way_ranging}. Wenn die Umlaufzeit beim \Gls{tag} berechnet werden soll, müssen die Zeitspannen $T_{reply1}$ und $T_{round2}$ zum \Gls{tag} übermittelt werden. Für die letzte Zeitspanne erfolgt das mit einer vierten Nachricht die in dem Schaubild nicht abgebildet ist. \cite{decawave2015twr, decawave2016dw1kusermanual}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.70\linewidth]{double_sided_two_way_ranging}
	\caption{Ablauf des \acrlong{dstwr}.}
	\source{\citetitle{decawave2016dw1kusermanual} \cite{decawave2016dw1kusermanual}}
	\label{fig:double_sided_two_way_ranging}
\end{figure}

Die ungefähre \Gls{tof}--Zeitspanne ergibt sich aus der folgenden Gleichung:

\[T_{prop}=\frac{\left(T_{round1}\times T_{round2}-T_{reply1}\times T_{reply2}\right)}{\left(T_{round1}+T_{round2}+T_{reply1}+T_{reply2}\right)}\]

Der Fehler bei diesem Verfahren ergibt sich aus der folgenden Gleichung:

\[error=T_{prop}\times\left(1-\frac{k_a+k_b}{2}\right)\] 

Die Variablen $k_a$ und $k_b$ entsprechen hierbei den Offsetfehler der Zeitgeber von der Nennfrequenz und liegen beide sehr nahe bei eins.

Mit diesem Verfahren ist es auch möglich, gleichzeitig die Entfernungen zu mehr als einem \Gls{anchor} zu bestimmen, siehe \figurename~\ref{fig:double_sided_two_way_ranging_with_three_anchor}. Hierbei weist der \Gls{tag} in der initialen Nachricht jedem \Gls{anchor} eine individuelle Antwortzeit zu. Danach wartet er bist alle Antwortnachrichten angekommen sind um im der letzten Nachricht, dann jedem \Gls{anchor} seine Umlauf-- und Antwortzeiten zu übermitteln. Jeder \Gls{anchor} kann nun individuell die \Gls{tof}--Zeitspanne für sich berechnen und dann dem \Gls{tag} übermitteln. Diese letzte Nachricht ist auf der \figurename~\ref{fig:double_sided_two_way_ranging_with_three_anchor} nicht aufgeführt.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\linewidth]{double_sided_two_way_ranging_with_three_anchor}
	\caption{Ablauf des \acrlong{dstwr} mit einem \Gls{tag} und drei \Gls{anchor}.}
	\source{\citetitle{decawave2016dw1kusermanual} \cite{decawave2016dw1kusermanual}}
	\label{fig:double_sided_two_way_ranging_with_three_anchor}
\end{figure}

In der \figurename~\ref{fig:double_sided_two_way_ranging_with_three_anchor} wurde in der initialen Nachricht jedem \Gls{anchor} eine individuelle Antwortzeit zugeordnet. Woher wusste der\Gls{tag} welche \Gls{anchor} vorhanden sind? Die Kommunikation zwischen \Gls{tag} und \Gls{anchor} kann in zwei Phasen unterteilt werden, siehe \figurename~\ref{fig:discovery_and_ranging_phase}. In der \textit{Discovery} Phase schickt der \Gls{tag} periodisch \textit{Blink} Nachrichten mit seiner Identifikationsnummer an alle Module in der Umgebung. Empfängt ein \Gls{anchor} diese Nachricht, nimmt er den \Gls{tag} in seiner Liste auf und übermittelt dem \Gls{tag} eine \textit{Ranging Init} Nachricht mit seiner Identifikationsnummer. Das \Gls{tag} seinerseits nimmt den \Gls{anchor} in seiner Liste auf und weiß nun auch welche \Gls{anchor} er in der nächsten Entfernungsmessung berücksichtigen muss. Die \textit{Ranging} Phase entspricht hierbei der bereits zuvor besprochenen Entfernungsmessung.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.40\linewidth]{discovery_and_ranging_phase}
	\caption{Ablauf der \textit{Discovery} und \textit{Range Phase} zwischen einem \Gls{tag} und mehreren \Gls{anchor}n.}
	\source{\citetitle{decawave2016dw1kusermanual} \cite{decawave2016dw1kusermanual}}
	\label{fig:discovery_and_ranging_phase}
\end{figure}


\begin{comment}
------------------------------------------------------------------------------------------
- Theorie: Wahrscheinlichkeitsverfahren
	- Positionsschätzer in Form einer Wahrscheinlichkeitsverteilung über den Zustandraum.
	- Kalman fitering
		- Multivariate Gaussian distribution (Mehrdimensionale Normalverteilung)
		- \url{https://de.wikipedia.org/wiki/Mehrdimensionale_Normalverteilung}
		- Kompakte Beschreibung der Normalverteilung über den Erwartungswert $\mu$ und die Kovarianzmatrix $\Sigma$ ($\mu$ und $\sigma^2$)
		- \url{https://matheguru.com/stochastik/normalverteilung.html}
	- Markov methods
		- Probability Grid
		- Robot--Position ist diskretisiert
		- Nutzen von Bayes Rule um Grids zu kombinieren/neuerzeugen
	- Monte Carlo Lokalisierung
		- Multimodal Distribution for position estimation
		- Important Sampling
- http://www.mathepedia.de/Stochastik.html
- https://www.youtube.com/watch?v=DoHTsDrzAQk
\end{comment}
\section{Wahrscheinlichkeitstheorie [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
- https://matheguru.com/stochastik/standardfehler.html
- https://de.wikipedia.org/wiki/Standardfehler
- Theorie: Lokalisierungsprobleme
	- Statische Lokalisierung
		- Akkurate Schätzung seiner globalen Position anhand der Sensordaten
		- Annahme: Umgebungskarte der Landmarken ist vorhanden
	- Position Tracking/Positionsverfolgung
		- Initiale Position ist gegeben
		- Verfogenden der Roboterposition
		- Annahme: Umgebungskarte der Landmarken ist vorhanden
	- SLAM
		- Verwenden der Sensordaten um sich zu Lokalisierung...
		- und eine Karte der Landmarken zu erzeugen.
		- Bisher Winkel und Entferung zu einer Landmarke gegeben
			- Computer Vision, Structure from Motion
		- Hier nur die Entfernung
\end{comment}
\section{Bayes Filter [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
- \cite{kalman1960new}
- \cite{kurth2003experimental}
	- Originally introduced in 1960, the Kalman lter assumes a multivariate Gaussian distribution [6]. The Kalman lter has the advantage that the representation of the distribution is compact; a Gaussian distribution can be represented by a mean and a covariance matrix. The robot's pose estimation is maintained as a Gaussian distribution and sensor data from dead reckoning and landmark observations is fused to obtain a new position distribution.
	- Our results with Kalman ltering require an under-standing of the characteristics of the noise present in ranges reported by the radio tags. We gain this by look-ing at the probability distribution functions for each tag measurement.
	- We obtain the PDFs as follows: for every reported measurement, we nd the true range to the robot when that distance was reported. We do this by comparing the known location of the reporting tag to the times-tamped true location of the robot when the report was received.
	- the covariance matrix, which describes the uncertainty and correlation of the terms in the state estimate.
	- However, when the same initial noisy tag locations are used with Test 2, our SLAM technique fails to converge. Since the Kalman lter uses a linearization of the nonlinear range measurements, if the linearized estimate is too far away from the truth, the lter may be unable to recover and will diverge.
	-

\end{comment}
\subsection{Kalman Filter [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
- \cite{kurth2003experimental}
	- Recent extensions of Kalman ltering allow for non-Gaussian, multimodal probability distributions through multiple hypothesis tracking. The result is a more versatile estimation technique that still preserves many of the computational advantages of the Kalman filter.
\end{comment}
\subsection{Extended Kalman Filter [todo]}

% Linearisierung


\begin{comment}
------------------------------------------------------------------------------------------
\end{comment}
\section{Partikel Filter [todo]}

\begin{comment}
------------------------------------------------------------------------------------------
- \cite{kurth2003experimental}
	- Monte Carlo localization, or particle ltering, provides a method of representing multimodal distri-butions for position estimation [4, 12], with the ad-vantage that the computational requirements can be scaled. The main advantage of these methods is their ability to recover robustly from a poor initial condition.
- \cite{fox1999monte}
\end{comment}
\subsection{Monte Carlo [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
Rao-Blackwellized Particle Filtering
https://people.eecs.berkeley.edu/~pabbeel/cs287-fa12/slides/RBPF.pdf

- \cite{murphy2001rao}
	- Rao-Blackwellised particle filtering for dynamic Bayesian networks
\end{comment}
\subsection{Rao-Blackwellized [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
- \cite{kurth2003experimental}
	- We are currently developing a batch localization method, which considers all the data collected by the robot and nds the best path estimate given all the data. Although time consuming computationally, this will produce the theoretically optimal result obtainable from the collected data; we can then evaluate the results of our online localization method by comparing to this optimal solution.
\end{comment}
%\section{Batch optimization [todo,optional]}


\begin{comment}
------------------------------------------------------------------------------------------
- \cite{kurth2003experimental}
	- Additionally, we will extend the batch method to produce a variable dimension lter, as used by Deans for the case of bearing-only sensors [3], which would consider some window of previous robot states and optimize the position estimates based on the data in that window.
\end{comment}
%\section{Variable Dimension Filter [todo,optional]}


\begin{comment}
------------------------------------------------------------------------------------------
Embodied Localisation and Mapping
http://elib.suub.uni-bremen.de/edocs/00103537-1.pdf


- \citez{montemerlo2002fastslam}
	- FastSLAM: A factored solution to the simultaneous localization and mapping problem

- \cite{sarkka2013bayesian}
	- Bayesian filtering and smoothing
- \cite{kurth2003experimental}
	- The Kalman lter approach described in Section 5 can be reformulated for the SLAM problem. To perform SLAM, we include position estimates for each tag in the state, producing a state vector of the form: q(k) = [xk; yk; k; xb1; yb1 ; :::; xbn; ybn]T , where n is the number of beacons.
	
- The purpose of a probabilistic approach to RO-SLAM is to obtain the joint probability distribution of the robot pose (or path) and the map, given all the available data at some instant of time. This distribution represents our knowledge about the robot path, the map, and all their correlations.
\end{comment}
\section{SLAM [todo]}

% Zuerst wird die Position geschätzt und danach die Positionen der Landmarken.

\begin{comment}
------------------------------------------------------------------------------------------
\end{comment}
\subsection{RO--SLAM [todo]}


\begin{comment}
------------------------------------------------------------------------------------------
- Launch Files
	- Tool to manage a robotic system
	- starting of multiple nodes
	- setting of parameter values
	- setting of arguments
	- including other launch files
- Parameter Server
	- Global key-value store for sharing configuration informationen
- Transformation
	- static
	- dynamic
	- TFs are implemented with a forward description from parent to child (from → to )
	- Each child frame has a maximum of one parent frame, but a parent frame can be linked to many child frames (tree structured)
	- Listener / Broadcaster
\end{comment}
\section{Robot Operating System}

Bei dem \Gls{ros} handelt es sich nicht im eigentlichen Sinne um ein Betriebssystem, sondern vielmehr um ein Framework das die Kommunikation zwischen verschiedenen Verarbeitungseinheiten regelt. Im Jahre 2007 begann die Entwicklung von \Gls{ros} an der Stanford University. Ab 2009 wurde dieses dann hauptsächlich an dem Robotik Institut Willow Garage weiterentwickelt. Durch die BSD Lizenz steht \Gls{ros} als Open--Source--Projekt sowohl der nicht--kommerziellen auch der kommerziellen Weiterentwicklung zur Verfügung. \cite{quigley2009ros}

Jedes \Gls{ros}--System muss über einen \Gls{ros}--Master verfügen. Dieser stellt den zentralen Punkt für die Registrierung von \textit{Nodes}, \textit{Topics} und \textit{Services} zur Verfügung.

Jeder Verarbeitungseinheit in \Gls{ros} wird durch einen \textit{Node} repräsentiert. Ziel ist es möglichst kleine wiederverwendbare und miteinander kombinierbare Einheiten zu bilden. Die Programmierung eines \textit{Nodes} erfolgt dabei in den Programmiersprachen C++, Python oder Lisp.

Die Kommunikation zwischen den \textit{Nodes} erfolgt dabei über ein \Gls{p2p}--Kanal auf der Basis von \textit{Messages}. Bei einer \textit{Message} handelt es sich um eine Datenstruktur die primitive Datentypen, andere \textit{Messages} und Felder enthalten kann. Eine \textit{Message} wird dabei über das \textit{Publish--Subscribe} Muster in einem \textit{Topic} veröffentlicht und kann von jedem \textit{Node} empfangen werden der dieses \textit{Topic} abonniert hat. Der typische Anwendungsfall für dieses Verfahren ist die Bereitstellung von Sensordaten und Rückmeldungen über Statusänderungen.

Das zuvor vorgestellte \textit{Publish--Subscribe} Muster stellt eine asynchrone Kommunikation bereit. Mit Hilfe von \textit{Services} ist auch ein synchroner \textit{Message} Austausch möglich. Hierfür wird eine Anfrage von dem \textit{Client} an den \textit{Server} gestellt, der seinerseits mit einem Ergebnis antwortet. Dieses Verfahren entspricht dem \textit{Request--Response} Muster. Die Erstellung einer inversen Transformation ist ein typischer Anwendungsfall hierfür.

Nach der Entwicklung neuer Algorithmen ist ein Vergleich mit den bereits bestehenden Algorithmen von großem Interesse. Mit dem Konzept der \textit{Bag}--Dateien können alle veröffentlichten Nachrichten aufgezeichnet werden und zu einem späteren Zeitpunkt wieder abgespielt werden.

Um die Wiederverwendbarkeit von \textit{Nodes}, \textit{Messages} und \textit{Services} zu fördern, wurde das Konzept der \textit{Packages} eingeführt. Ein \textit{Package} stellt die kleinste erstellbare Einheit dar und beinhaltet alle Teile eines Softwarepaketes wie z.B. Quellcode--, Konfigurationsdateien, Drittanbieter Bibliothek, Abhängigkeitslisten usw.

